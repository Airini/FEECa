<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>FEECa - FiniteElementSpace</title>
        <link rel="stylesheet" type="text/css" href="../../web/css/default.css" />
    </head>
    <body>

      <div style="width: 1200px; align: center" , id="container">
      <div id="menu">
        <h2 class="nav"> FEECa </h2>
        <ul class="main" style="list-style: none;">
        <li><a href="../../">Home</a></li>
        <li><a href="../../">Examples</a></li>
        <li> Documentation
            <ul class="menu">
            <li class="menu"><label>FEECa</label><ul class="menu"><li class="menu"><a href="../../src/FEECa/Bernstein.html">Bernstein.lhs</a></li><li class="menu"><a href="../../src/FEECa/FiniteElementSpace.html">FiniteElementSpace.lhs</a></li><li class="menu"><label>Internal</label><ul class="menu"><li class="menu"><a href="../../src/FEECa/Internal/MultiIndex.html">MultiIndex.lhs</a></li><li class="menu"><a href="../../src/FEECa/Internal/Point.html">Point.lhs</a></li><li class="menu"><a href="../../src/FEECa/Internal/Simplex.html">Simplex.lhs</a></li><li class="menu"><a href="../../src/FEECa/Internal/Vector.html">Vector.lhs</a></li></ul></li><li class="menu"><a href="../../src/FEECa/Polynomial.html">Polynomial.lhs</a></li><li class="menu"><a href="../../src/FEECa/PolynomialDifferentialForm.html">PolynomialDifferentialForm.lhs</a></li><li class="menu"><label>Utility</label><ul class="menu"><li class="menu"><a href="../../src/FEECa/Utility/Combinatorics.html">Combinatorics.lhs</a></li></ul></li></ul></li>
            </ul>
        </li>
        </ul>
       </div>

      <div id="main">
        <div id="content">

            <h1 id="finite-element-spaces">Finite Element Spaces</h1>
<p>The <span><code>FiniteElementSpace</code></span> module provides functions for the generation of finite element bases over simplices. The implementation is based on the article by Arnold, Falk and Winther <span class="citation">Arnold, Falk, and Winther (2009)</span>.</p>
<p>Bases are provided for the two families of spaces <span class="math inline">\({\mathcal{P}_{r}\Lambda^{k}}\)</span> and <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span>. <span class="math inline">\({\mathcal{P}_{r}\Lambda^{k}}\)</span> is the space of polynomial differential <span class="math inline">\(k\)</span>-forms of degree at most <span class="math inline">\(r\)</span>. The space <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span> is defined as</p>
<p><span class="math display">\[\begin{aligned}
{\mathcal{P}_{r}^-\Lambda^{k}} &amp;= \{ \omega \in {\mathcal{P}_{r}\Lambda^{k}} | \kappa \omega \in {\mathcal{P}_{r}\Lambda^{k-1}} \}\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\kappa\)</span> is the Koszul operator.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kw">module</span> <span class="dt">FEECa.FiniteElementSpace</span> (
                                <span class="dt">FiniteElementSpace</span>(<span class="fu">..</span>),
                                <span class="dt">Name</span>(<span class="fu">..</span>),
                                finiteElementSpace,
                                <span class="dt">BasisFunction</span>,
                                <span class="dt">Simplex</span>,
                                <span class="dt">Vector</span>,
                                basis,
                                vspaceDim,
                                whitneyForm,
                                prmLkBasis,
                                          prmLkFace,
                                                   psi'
 <span class="co">-- * Introduction</span>
 <span class="co">-- $intro</span>
)<span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">FEECa.Bernstein</span> (constant, monomial, multiIndices)
<span class="kw">import qualified</span> <span class="dt">FEECa.Bernstein</span> <span class="kw">as</span> <span class="dt">B</span> (<span class="dt">BernsteinPolynomial</span>(..),extend)
<span class="kw">import </span><span class="dt">FEECa.Utility.Combinatorics</span>
<span class="kw">import qualified</span> <span class="dt">FEECa.PolynomialDifferentialForm</span> <span class="kw">as</span> <span class="dt">D</span>
<span class="kw">import </span><span class="dt">FEECa.Utility.Print</span>( printBernstein, printForm, dlambda )
<span class="kw">import qualified</span> <span class="dt">FEECa.Utility.Print</span> <span class="kw">as</span> <span class="dt">P</span> ( <span class="dt">Pretty</span>(..) )
<span class="kw">import </span><span class="dt">FEECa.Internal.Form</span> <span class="kw">hiding</span> (arity, inner)
<span class="kw">import qualified</span> <span class="dt">FEECa.Internal.Form</span> <span class="kw">as</span> <span class="dt">F</span>(inner)
<span class="kw">import qualified</span> <span class="dt">FEECa.Internal.Simplex</span> <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import </span><span class="dt">FEECa.Internal.Spaces</span> <span class="kw">hiding</span> (inner)
<span class="kw">import qualified</span> <span class="dt">FEECa.Internal.Spaces</span> <span class="kw">as</span> <span class="dt">S</span>(inner)
<span class="kw">import qualified</span> <span class="dt">FEECa.Internal.Vector</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import qualified</span> <span class="dt">FEECa.Internal.MultiIndex</span> <span class="kw">as</span> <span class="dt">MI</span>
<span class="kw">import qualified</span> <span class="dt">Math.Combinatorics.Exact.Binomial</span> <span class="kw">as</span> <span class="dt">CBin</span>
<span class="kw">import </span><span class="dt">Debug.Trace</span>

<span class="co">-- $intro</span>
<span class="co">-- This file implements the finite element space $P_r\Lambda^k$ and $P_r^-\Lambda^k$</span>
<span class="co">--  in n dimensions. The implementation is based on the article &quot;Geomentric De-</span>
<span class="co">-- compositions and Local Bases for Spaces of Finite Element Differential Forms&quot; by</span>
<span class="co">-- Arnold, Falk, Winther. References given in the comments refer to this article.</span></code></pre></div>
<h2 id="the-finiteelementspace-data-type">The <span><code>FiniteElementSpace</code></span> Data Type</h2>
<p>For the handling of finite element spaces the <span><code>FiniteElementSpace</code></span> module provides the <span><code>FiniteElementSpace</code></span> type which represents a finite element space over a simplex. It provides three type constructors. The <span><code>PrLk</code></span> and the <span><code>PrmLk</code></span> constructors to represent the spaces <span class="math inline">\({\mathcal{P}_{r}\Lambda^{k}}\)</span> and <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span>, respectively and the <span><code>GenSpace</code></span> constructor to represent a general space by a set of basis functions.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Vector</span> <span class="fu">=</span> <span class="dt">V.Vector</span> <span class="dt">Double</span>
<span class="kw">type</span> <span class="dt">Simplex</span> <span class="fu">=</span> <span class="dt">S.Simplex</span> <span class="dt">Vector</span>
<span class="kw">type</span> <span class="dt">BernsteinPolynomial</span> <span class="fu">=</span> <span class="dt">D.BernsteinPolynomial</span> <span class="dt">Double</span>
<span class="kw">type</span> <span class="dt">DifferentialForm</span> <span class="fu">=</span> <span class="dt">D.DifferentialForm</span> <span class="dt">Double</span>

<span class="co">-- | Data type for the two families of finite element spaces $P_r\Lambda^k$ and</span>
<span class="co">-- | $P_r^-\Lambda^k$ defined over a simplex.</span>
<span class="kw">data</span> <span class="dt">FiniteElementSpace</span> <span class="fu">=</span> <span class="dt">PrLk</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Simplex</span>
                        <span class="fu">|</span> <span class="dt">PrmLk</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Simplex</span>
                          <span class="kw">deriving</span>( <span class="dt">Show</span> )

<span class="co">-- | Type synomym for basis function of finite element spaces that are of type</span>
<span class="co">-- | Form BernsteinPolynomial.</span>
<span class="kw">type</span> <span class="dt">BasisFunction</span> <span class="fu">=</span> <span class="dt">DifferentialForm</span></code></pre></div>
<p>For the <span class="math inline">\({\mathcal{P}_{r}\Lambda^{k}}\)</span> and <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span> spaces the following functions can be used to extract their properties. <span><code>degree</code></span> returns the maximum degree <span class="math inline">\(r\)</span> of the spaces, while <span><code>arity</code></span> returns the arity <span class="math inline">\(k\)</span> of the alternating forms. <span><code>vspaceDim</code></span> returns the dimension <span class="math inline">\(n\)</span> of the underlying euclidean space <span class="math inline">\({\mathbb{R}^{n}}\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="co">-- | The degree of the finite element space.</span>
<span class="ot">degree ::</span> <span class="dt">FiniteElementSpace</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
degree (<span class="dt">PrLk</span> r _ _) <span class="fu">=</span> r
degree (<span class="dt">PrmLk</span> r _ _) <span class="fu">=</span> r

<span class="co">-- | The arity of the finite element space</span>
<span class="ot">arity ::</span> <span class="dt">FiniteElementSpace</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
arity (<span class="dt">PrLk</span> _ k _) <span class="fu">=</span> k
arity (<span class="dt">PrmLk</span> _ k _) <span class="fu">=</span> k

<span class="co">-- | The dimension of the underlying vector space.</span>
<span class="ot">vspaceDim ::</span> <span class="dt">FiniteElementSpace</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
vspaceDim (<span class="dt">PrLk</span> _ _ t) <span class="fu">=</span> S.geometricalDimension t
vspaceDim (<span class="dt">PrmLk</span> _ _ t) <span class="fu">=</span> S.geometricalDimension t</code></pre></div>
<p>The function <span><code>dim</code></span> can be used to compute the dimension of the spaces which are given by</p>
<p><span class="math display">\[\begin{aligned}
      \text{dim }{\mathcal{P}_{r}^-\Lambda^{k}} &amp;= { \left ( \begin{array}{c} n + r \\ n \end{array} \right ) }{ \left ( \begin{array}{c} n \\ k \end{array} \right ) } \\
      \text{dim }{\mathcal{P}_{r}^-\Lambda^{k}} &amp;= { \left ( \begin{array}{c} r + k - 1 \\ k \end{array} \right ) }{ \left ( \begin{array}{c}  n + r  \\  n - k  \end{array} \right ) }\end{aligned}\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">

<span class="co">-- | The dimension of the finite element space.</span>
<span class="kw">instance</span> <span class="dt">Dimensioned</span> <span class="dt">FiniteElementSpace</span> <span class="kw">where</span>
    dim (<span class="dt">PrmLk</span> r k t) <span class="fu">=</span> ((r <span class="fu">+</span> k <span class="fu">-</span> <span class="dv">1</span>) <span class="ot">`CBin.choose`</span> k) <span class="fu">*</span> ((n <span class="fu">+</span> r) <span class="ot">`CBin.choose`</span> (n <span class="fu">-</span> k))
        <span class="kw">where</span> n <span class="fu">=</span> S.geometricalDimension t
    dim (<span class="dt">PrLk</span> r k t) <span class="fu">=</span> ((r <span class="fu">+</span> k) <span class="ot">`CBin.choose`</span> r ) <span class="fu">*</span> ((n <span class="fu">+</span> r) <span class="ot">`CBin.choose`</span> (n <span class="fu">-</span> k))
        <span class="kw">where</span> n <span class="fu">=</span> S.geometricalDimension t</code></pre></div>
<p>Finally, the actual work is performed by the <span><code>basis</code></span> function which computes the basis elements of a given <span class="math inline">\({\mathcal{P}_{r}\Lambda^{k}}\)</span> or <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span> space. The implementation is described below.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="co">-- | List the basis functions of the given finite element space.</span>
<span class="ot">basis ::</span> <span class="dt">FiniteElementSpace</span> <span class="ot">-&gt;</span> [<span class="dt">BasisFunction</span>]
basis (<span class="dt">PrmLk</span> r k t) <span class="fu">=</span> prmLkBasis r k t
basis (<span class="dt">PrLk</span> r k t) <span class="fu">=</span> prLkBasis r k t

<span class="ot">pPrintBasisFunction ::</span> <span class="dt">BasisFunction</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
pPrintBasisFunction <span class="fu">=</span> show <span class="fu">.</span> printForm dlambda <span class="st">&quot;0&quot;</span> P.pPrint
                           <span class="fu">.</span> terms

<span class="ot">pPrint ::</span> [<span class="dt">BasisFunction</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
pPrint [] <span class="fu">=</span> putStrLn <span class="st">&quot;Empty List\n&quot;</span>
pPrint l  <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;[ &quot;</span> <span class="fu">++</span> foldl render (pPrintBasisFunction (head l)) (tail l)
                            <span class="fu">++</span> <span class="st">&quot;]&quot;</span>
    <span class="kw">where</span> render s bf <span class="fu">=</span> s <span class="fu">++</span> <span class="st">&quot;,\n&quot;</span> <span class="fu">++</span> pPrintBasisFunction bf</code></pre></div>
<h2 id="concrete-spaces">Concrete Spaces</h2>
<p>For the construction of finite element spaces over a given simplex the <span><code>finiteElementSpace</code></span> function is provided. It takes the name of one of the primary spaces of finite elements as presented in <span class="citation">Arnold and Logg (2014)</span>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | Name data type to represent the named finite elements. See</span>
<span class="co">-- | &lt;http://www.femtable.org Periodic Table of the Finite Elements&gt;.</span>
<span class="kw">data</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">P</span>
          <span class="fu">|</span> <span class="dt">Pm</span>
          <span class="fu">|</span> <span class="dt">DP</span>
          <span class="fu">|</span> <span class="dt">DPm</span>
          <span class="fu">|</span> <span class="dt">RT</span>
          <span class="fu">|</span> <span class="dt">N1e</span>
          <span class="fu">|</span> <span class="dt">N1f</span>
          <span class="fu">|</span> <span class="dt">BDM</span>
          <span class="fu">|</span> <span class="dt">N2e</span>
          <span class="fu">|</span> <span class="dt">N2f</span>

<span class="co">-- | Create named finite element space of given polynomial degree over the</span>
<span class="co">-- | given simplex.</span>
<span class="ot">finiteElementSpace ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">FiniteElementSpace</span>
finiteElementSpace <span class="dt">P</span> r t <span class="fu">=</span> <span class="dt">PrLk</span> r <span class="dv">0</span> t
finiteElementSpace <span class="dt">Pm</span> r t <span class="fu">=</span> <span class="dt">PrmLk</span> r <span class="dv">0</span> t
finiteElementSpace <span class="dt">DP</span> r t <span class="fu">=</span> <span class="dt">PrLk</span> r (S.topologicalDimension t) t
finiteElementSpace <span class="dt">DPm</span> r t <span class="fu">=</span> <span class="dt">PrmLk</span> r (S.topologicalDimension t) t
finiteElementSpace <span class="dt">RT</span> r t
    <span class="fu">|</span> S.topologicalDimension t <span class="fu">==</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">PrmLk</span> r <span class="dv">1</span> t
    <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="st">&quot;RT elements are defined in two dimensions.&quot;</span>
finiteElementSpace <span class="dt">N1e</span> r t
    <span class="fu">|</span> S.topologicalDimension t <span class="fu">==</span> <span class="dv">3</span> <span class="fu">=</span> <span class="dt">PrmLk</span> r <span class="dv">1</span> t
    <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="st">&quot;N1e1 elements are defined in three dimensions.&quot;</span>
finiteElementSpace <span class="dt">N1f</span> r t
    <span class="fu">|</span> S.topologicalDimension t <span class="fu">==</span> <span class="dv">3</span> <span class="fu">=</span> <span class="dt">PrmLk</span> r <span class="dv">2</span> t
    <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="st">&quot;N1f1 elements are defined in three dimensions.&quot;</span>
finiteElementSpace <span class="dt">BDM</span> r t
    <span class="fu">|</span> S.topologicalDimension t <span class="fu">==</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">PrLk</span> r <span class="dv">1</span> t
    <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="st">&quot;BDM elements are defined in two dimensions.&quot;</span>
finiteElementSpace <span class="dt">N2e</span> r t
    <span class="fu">|</span> S.topologicalDimension t <span class="fu">==</span> <span class="dv">3</span> <span class="fu">=</span> <span class="dt">PrLk</span> r <span class="dv">1</span> t
    <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="st">&quot;N2e1 elements are defined in three dimensions.&quot;</span>
finiteElementSpace <span class="dt">N2f</span> r t
    <span class="fu">|</span> S.topologicalDimension t <span class="fu">==</span> <span class="dv">3</span> <span class="fu">=</span> <span class="dt">PrLk</span> r <span class="dv">2</span> t
    <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="st">&quot;N2f1 elements are defined in three dimensions.&quot;</span></code></pre></div>
<h2 id="construction-of-bases">Construction of Bases</h2>
<p>For the construction of finite element bases we use the geometric decompositions proposed in section 9 in <span class="citation">Arnold, Falk, and Winther (2009)</span>.</p>
<p>Let <span class="math inline">\({\mathcal{f}}\)</span> be a face of a simplex <span class="math inline">\({\mathcal{T}}\)</span> In the following we write <span class="math inline">\(\mathcal{I}({\mathcal{f}})\)</span> to denote the set of indices of vertices of <span class="math inline">\({\mathcal{T}}\)</span> included in the subsimplex <span class="math inline">\({\mathcal{f}}\)</span>. This is the same as the range of the map <span class="math inline">\(\sigma\)</span> representing the subsimplex</p>
<p><span class="math display">\[\begin{aligned}
  \mathcal{I}({\mathcal{f}}) &amp;= \text{range} ( \sigma )\end{aligned}\]</span></p>
<p>Moreover, we define the range operator applied to a face and a map <span class="math inline">\(\sigma\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
  \text{range}({\mathcal{f}},\sigma) = \mathcal{I}({\mathcal{f}}) \cup \text{range}(\sigma)\end{aligned}\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="co">-- | The range operator for a multi-index and an increasing list.</span>
range<span class="ot"> ::</span> <span class="dt">MI.MultiIndex</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
range mi sigma <span class="fu">=</span> sort sigma <span class="ot">`union`</span> MI.range mi</code></pre></div>
<h3 id="the-mathcalp_r-lambdak-spaces">The <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span> Spaces</h3>
<p>An import building block in the construction of bases for the <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span> spaces are the so called Whitney forms. Let <span class="math inline">\({\mathcal{f}}\)</span> be a subsimplex of <span class="math inline">\({\mathcal{T}}\)</span> and <span class="math inline">\(\sigma \in \Sigma(0:k,0:n)\)</span>. The Whitney form <span class="math inline">\(\phi_\sigma^{\mathcal{f}}\)</span> is defined as:</p>
<p><span class="math display">\[\begin{aligned}
  \phi_\sigma^{{\mathcal{f}}} &amp;= \sum_{i=0}^k (-1)^i\lambda^{\mathcal{f}}_i d\lambda^{{\mathcal{f}}}_0
                          \wedge \ldots \wedge d\lambda^{{\mathcal{f}}}_{i-1} \wedge
                          d\lambda^{{\mathcal{f}}}_{i+1} \wedge \ldots \wedge
                                          d\lambda^{{\mathcal{f}}}_k\end{aligned}\]</span></p>
<p>where we have used <span class="math inline">\(\lambda_i^{{\mathcal{f}}}\)</span> to denote the barycentric coordinates of the face <span class="math inline">\({\mathcal{f}}\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="co">-- | The Whitney forms as given by  equation (6.3).</span>
<span class="ot">whitneyForm ::</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>
whitneyForm t sigma <span class="fu">=</span> <span class="dt">Form</span> k n [ (lambda' i, subsets <span class="fu">!!</span> i) <span class="fu">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>k]]
    <span class="kw">where</span> k <span class="fu">=</span> length sigma <span class="fu">-</span> <span class="dv">1</span>
          n <span class="fu">=</span> S.topologicalDimension t
          subsets <span class="fu">=</span> sublists sigma
          lambda' i <span class="fu">=</span> sclV ((<span class="fu">-</span><span class="dv">1</span>)<span class="fu">^</span>i) (monomial t (MI.unit (n <span class="fu">+</span> <span class="dv">1</span>) (sigma <span class="fu">!!</span> i)))</code></pre></div>
<p>The Whitney form <span class="math inline">\(\phi_\sigma = \phi^{{\mathcal{T}}}\)</span> is obtained by extending the differential form to <span class="math inline">\(T\)</span>. The extension is performed simply by identifying the barycentric coordinates <span class="math inline">\(\lambda^{{\mathcal{f}}}_i\)</span> with the corresponding ones on the supersimplex</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="co">-- | Extend a differential Form defined on a face of a simplex to the full simplex.</span>
<span class="co">-- | Implements the barycentric extension operator defined in eq. (7.1) in</span>
<span class="co">-- | Arnold, Falk, Winther.</span>
<span class="ot">extend ::</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span> <span class="ot">-&gt;</span> <span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>
extend t (<span class="dt">Form</span> k n' cs) <span class="fu">=</span> <span class="dt">Form</span> k n (extend' cs)
    <span class="kw">where</span> extend' <span class="fu">=</span> map (\ (x,y) <span class="ot">-&gt;</span> (B.extend t x, extendFace n y))
          n <span class="fu">=</span> S.topologicalDimension t

<span class="co">-- | Extend the face of a subsimplex of a simplex of topological dimension n to the</span>
<span class="co">-- | the simplex. That is, for a face given as an increasing list of vertices of the</span>
<span class="co">-- | subsimplex, return the list of vertices of the simplex that corresponds to that</span>
<span class="co">-- | face.</span>
<span class="ot">extendFace ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
extendFace n f <span class="fu">=</span> [ [<span class="dv">0</span><span class="fu">..</span>n] <span class="fu">!!</span> (i<span class="fu">-</span><span class="dv">1</span>) <span class="fu">|</span> i <span class="ot">&lt;-</span> f ]</code></pre></div>
<p>Using the Whitney forms, a basis for <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span> can be constructed as follows. For given <span class="math inline">\(r\)</span>,<span class="math inline">\(k\)</span> and a simplex <span class="math inline">\({\mathcal{T}}\)</span>, a basis of the space <span class="math inline">\({\mathcal{P}_{r}^-\Lambda^{k}}\)</span> is given by the set</p>
<p><span class="math display">\[\begin{align}\label{eq:basis_pl}
  \{(\lambda)^{{\boldsymbol{\alpha}}} \phi_\sigma | \: &amp; {\boldsymbol{\alpha}} \in \mathrm{N}_0^{0:n},
   |{\boldsymbol{\alpha}}| = r-1, \\
  &amp; \sigma \in \Sigma(0:k,0:n), \text{range}({\boldsymbol{\alpha}},\sigma) = \mathcal{I}(f), \\
  &amp; \alpha_i = 0 \text{ if } i &lt; \text{min}\left ( \text{range}(\sigma) \right ) \}
\end{align}\]</span></p>
<p>The construction of this set is implemented in the function <span><code>prmLkBasis</code></span>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="co">-- | The basis of the $P_r^-\Lambda^k$ space over the given simplex constructed</span>
<span class="co">-- | using the geometric composition given by Anrold, Falk, Winther.</span>
<span class="ot">prmLkBasis ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> [<span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>]
prmLkBasis r k t <span class="fu">=</span> concat [prmLkFace t f r k <span class="fu">|</span> f <span class="ot">&lt;-</span> fs]
    <span class="kw">where</span> n      <span class="fu">=</span> S.topologicalDimension t
          fs     <span class="fu">=</span> concat [S.subsimplices t i <span class="fu">|</span> i <span class="ot">&lt;-</span> [k<span class="fu">..</span>n]]

<span class="co">-- | Basis for the space PrMinusLambdak with vanishing trace associated to</span>
<span class="co">-- | a given face of a simplex.</span>
<span class="ot">prmLkFace ::</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>]
prmLkFace t f r k <span class="fu">=</span> [ sclV (lambda a) (phi s) <span class="fu">|</span> a <span class="ot">&lt;-</span> alphas, s <span class="ot">&lt;-</span> sigmas, valid a s ]
    <span class="kw">where</span> alphas     <span class="fu">=</span> MI.degreeR (n<span class="fu">+</span><span class="dv">1</span>) (r<span class="fu">-</span><span class="dv">1</span>)
          sigmas     <span class="fu">=</span> increasingLists (k<span class="fu">+</span><span class="dv">1</span>) n
          n          <span class="fu">=</span> S.topologicalDimension t
          valid a s  <span class="fu">=</span> setEq (domain a s) (S.sigma f) <span class="fu">&amp;&amp;</span> zeros a s
          zeros a s  <span class="fu">=</span> <span class="dv">0</span> <span class="fu">==</span> sum (take (minimum s) (MI.toList a))
          setEq d l  <span class="fu">=</span> sort d <span class="fu">==</span> l
          domain a   <span class="fu">=</span> union (MI.range a)
          phi        <span class="fu">=</span> whitneyForm t
          lambda     <span class="fu">=</span> monomial t </code></pre></div>
<h3 id="the-mathcalp_rlambdak-spaces">The <span class="math inline">\({\mathcal{P}_{r}\Lambda^{k}}\)</span> Spaces</h3>
<p>The construction of the <span class="math inline">\({\mathcal{P}_{r}\Lambda^{k}}\)</span> spaces uses another set primitive <span class="math inline">\(k\)</span>-forms. Let <span class="math inline">\({\mathcal{f}}\)</span> be a face of another face <span class="math inline">\({\mathcal{g}}\)</span> of the simplex <span class="math inline">\({\mathcal{T}}\)</span>. Define <span class="math inline">\({\psi^{{\boldsymbol{\alpha}},{\mathcal{f}},{\mathcal{g}}}_{\sigma}}\)</span></p>
<p><span class="math display">\[\begin{aligned}
      {\psi^{{\boldsymbol{\alpha}},{\mathcal{f}},{\mathcal{g}}}_{i}} &amp;= d\lambda_i^{{\mathcal{g}}} -
          \frac{\alpha_i}{|\alpha|} \sum_{j \in \mathcal{I}({\mathcal{f}})} d\lambda_j^{\mathcal{g}} \\
     {\psi^{{\boldsymbol{\alpha}},{\mathcal{f}},{\mathcal{g}}}_{\sigma}} &amp;= {\psi^{{\boldsymbol{\alpha}},{\mathcal{f}},{\mathcal{g}}}_{\sigma{(1)}}} \wedge \ldots
                          \wedge {\psi^{{\boldsymbol{\alpha}},{\mathcal{f}},{\mathcal{g}}}_{\sigma{(k)}}}\end{aligned}\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | The psi forms that implement the extension operator for the $P_r\Lambda^k$</span>
<span class="co">-- | spaces as given in equations (8.1) and (8.2) in Arnold, Falk, Winther.</span>
<span class="ot">psi ::</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">MI.MultiIndex</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>
psi t f alpha sigma  <span class="fu">=</span> foldl (<span class="fu">/</span>\) unit [psi' t f alpha i <span class="fu">|</span> i <span class="ot">&lt;-</span> sigma]
    <span class="kw">where</span> unit <span class="fu">=</span> nullForm n mulId
          n <span class="fu">=</span> dim alpha <span class="fu">-</span> <span class="dv">1</span>

<span class="co">-- TODO: Check form indices.</span>
<span class="ot">psi' ::</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">MI.MultiIndex</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>
psi' t f alpha i <span class="fu">=</span> foldl subV (db i) [ sclV (c j) (db j) <span class="fu">|</span> j <span class="ot">&lt;-</span> sigma]
    <span class="kw">where</span> db j   <span class="fu">=</span> sclV (constant t <span class="fl">1.0</span>) <span class="fu">$</span> oneForm j n
          c j    <span class="fu">=</span> sclV ((alpha' <span class="fu">!!</span> i) <span class="fu">/</span> r) mulId
          r      <span class="fu">=</span> fromInteger <span class="fu">$</span> MI.degree alpha
          alpha' <span class="fu">=</span> map fromInteger <span class="fu">$</span> MI.toList alpha
          n      <span class="fu">=</span> S.geometricalDimension f
          sigma  <span class="fu">=</span> S.sigma f</code></pre></div>
<p>where <span class="math inline">\(\sigma \in \Sigma(0:k,0:n)\)</span> and <span class="math inline">\(k\)</span> and <span class="math inline">\(n\)</span> the topological dimensions of <span class="math inline">\({\mathcal{f}}\)</span> and <span class="math inline">\({\mathcal{g}}\)</span>, respectively.</p>
<p>A basis for the space <span class="math inline">\({\mathcal{P}_{r}\Lambda^{k}}\)</span> is then given by the set</p>
<p><span class="math display">\[\begin{align}\label{eq:basis_pml}
  \{(\lambda^{{\mathcal{T}}})^{{\boldsymbol{\alpha}}} \psi_\sigma | \: &amp; {\boldsymbol{\alpha}} \in \mathrm{N}_0^{0:n},
   |{\boldsymbol{\alpha}}| = r, \\
  &amp; \sigma \in \Sigma(1:k,0:n), \text{range}({\boldsymbol{\alpha}},\sigma) = \mathcal{I}(f), \\
  &amp; \alpha_i = 0 \text{ if } i &lt; \text{min}\left (\mathcal{I}({\mathcal{f}}) /\ \text{range}(\sigma) \right ) \}
\end{align}\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="co">-- | Basis of the $P_r\Lambda^k$ space over the given simplex constructed using</span>
<span class="co">-- | the geometric decomposition given by Arnold, Falk, Winther.</span>
<span class="ot">prLkBasis ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> [<span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>]
prLkBasis r k t <span class="fu">=</span> concat [prLkFace t f r k <span class="fu">|</span> f <span class="ot">&lt;-</span> fs]
    <span class="kw">where</span> n  <span class="fu">=</span> S.topologicalDimension t
          fs <span class="fu">=</span> concat [S.subsimplices t i <span class="fu">|</span> i <span class="ot">&lt;-</span> [k<span class="fu">..</span>n]]

<span class="co">-- | Basis functions  for the space PrMinusLambdak associated to</span>
<span class="co">-- | a given face of a simplex.</span>
<span class="ot">prLkFace ::</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>]
prLkFace t f r k <span class="fu">=</span> [ sclV (lambda a) (psi'' a s) <span class="fu">|</span> a <span class="ot">&lt;-</span> alphas, s <span class="ot">&lt;-</span> sigmas, valid a s ]
    <span class="kw">where</span> alphas     <span class="fu">=</span> MI.degreeR (n<span class="fu">+</span><span class="dv">1</span>) r
          sigmas     <span class="fu">=</span> increasingLists k n
          n          <span class="fu">=</span> S.topologicalDimension t
          valid a s  <span class="fu">=</span> setEq (domain a s) (S.sigma f) <span class="fu">&amp;&amp;</span> zeros a s
          zeros a s  <span class="fu">=</span> <span class="dv">0</span> <span class="fu">==</span> sum (take (minimum' <span class="fu">$</span> S.sigma f \\ s) (MI.toList a))
          setEq d l  <span class="fu">=</span> sort d <span class="fu">==</span> l
          domain a s <span class="fu">=</span> MI.range a <span class="ot">`union`</span> s
          psi''      <span class="fu">=</span> psi t f
          lambda     <span class="fu">=</span> monomial t
          minimum' s <span class="fu">=</span> <span class="kw">if</span> null s <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> minimum s

<span class="co">-- | Basis for the space PrMinusLambdak with vanishing trace associated to</span>
<span class="co">-- | a given face of a simplex.</span>
<span class="ot">prLkFace' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> <span class="ot">-&gt;</span> [<span class="dt">Form</span> <span class="dt">BernsteinPolynomial</span>]
prLkFace' r k t <span class="fu">=</span> [<span class="dt">Form</span> k n [(b alpha, sigma)] <span class="fu">|</span> alpha <span class="ot">&lt;-</span> alphas,
                                                   sigma <span class="ot">&lt;-</span> sigmas alpha]
    <span class="kw">where</span> n <span class="fu">=</span> S.topologicalDimension t
          b <span class="fu">=</span> monomial t
          alphas <span class="fu">=</span> MI.degreeR (n <span class="fu">+</span> <span class="dv">1</span>)  r
          sigmas alpha <span class="fu">=</span> [ sigma <span class="fu">|</span> sigma <span class="ot">&lt;-</span> increasingLists k n,
                                   range alpha sigma <span class="fu">==</span> [<span class="dv">0</span><span class="fu">..</span>n],
                                   zero alpha sigma ]
          zero alpha sigma <span class="fu">=</span> all (<span class="dv">0</span><span class="fu">==</span>) (take (minimum' sigma) (MI.toList alpha))
          minimum' sigma <span class="fu">=</span> minimum ([<span class="dv">0</span><span class="fu">..</span>n] \\ sigma)

t <span class="fu">=</span> S.referenceSimplex <span class="dv">2</span>
t2 <span class="fu">=</span> S.subsimplex t <span class="dv">2</span> <span class="dv">0</span>
t1 <span class="fu">=</span> S.subsimplex t <span class="dv">1</span> <span class="dv">0</span>

b <span class="fu">=</span> monomial t1 (MI.multiIndex [<span class="dv">1</span>,<span class="dv">2</span>])
omega <span class="fu">=</span> <span class="dt">Form</span> <span class="dv">2</span> <span class="dv">2</span> [(b, [<span class="dv">0</span>,<span class="dv">1</span>])]<span class="ot"> ::</span> <span class="dt">DifferentialForm</span>
eta <span class="fu">=</span> <span class="dt">Form</span> <span class="dv">0</span> <span class="dv">2</span> [(b,[<span class="dv">0</span>])]

alpha <span class="fu">=</span> MI.multiIndex [<span class="dv">2</span>,<span class="dv">1</span>]
sigma <span class="fu">=</span> [<span class="dv">0</span>,<span class="dv">1</span>]
s1 <span class="fu">=</span> finiteElementSpace <span class="dt">N2f</span> <span class="dv">3</span> t</code></pre></div>
<h1 id="bibliography" class="unnumbered">Bibliography</h1>
<div id="refs" class="references">
<div id="ref-ArnoldLogg">
<p>Arnold, Douglas N., and Anders Logg. 2014. “Peridoc Table of the Finite Elements.” <em>SIAM News</em> 47 (9). <a href="http://femtable.org" class="uri">http://femtable.org</a>.</p>
</div>
<div id="ref-ArnoldFalkWinther">
<p>Arnold, Douglas N., Richard S. Falk, and Ragnar Winther. 2009. “Geometric Decompositions and Local Bases for Spaces of Finite Element Differential Forms.” <em>Comput. Methods Appl. Mech. Engrg.</em> 198: 1660–72. <a href="http://umn.edu/~arnold/papers/decomp.pdf" class="uri">http://umn.edu/~arnold/papers/decomp.pdf</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
      </div>
      </div>

    </body>
</html>
