<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>FEECa - Simplex</title>
        <link rel="stylesheet" type="text/css" href="../../../web/css/default.css" />
    </head>
    <body>

      <div style="width: 1200px; align: center" , id="container">
      <div id="menu">
        <h2 class="nav"> FEECa </h2>
        <ul class="main" style="list-style: none;">
        <li><a href="../../../">Home</a></li>
        <li><a href="../../../">Examples</a></li>
        <li> Documentation
            <ul class="menu">
            <li class="menu"><label>FEECa</label><ul class="menu"><li class="menu"><a href="../../../src/FEECa/Bernstein.html">Bernstein.lhs</a></li><li class="menu"><a href="../../../src/FEECa/FiniteElementSpace.html">FiniteElementSpace.lhs</a></li><li class="menu"><label>Internal</label><ul class="menu"><li class="menu"><a href="../../../src/FEECa/Internal/MultiIndex.html">MultiIndex.lhs</a></li><li class="menu"><a href="../../../src/FEECa/Internal/Point.html">Point.lhs</a></li><li class="menu"><a href="../../../src/FEECa/Internal/Simplex.html">Simplex.lhs</a></li><li class="menu"><a href="../../../src/FEECa/Internal/Vector.html">Vector.lhs</a></li></ul></li><li class="menu"><a href="../../../src/FEECa/Polynomial.html">Polynomial.lhs</a></li><li class="menu"><a href="../../../src/FEECa/PolynomialDifferentialForm.html">PolynomialDifferentialForm.lhs</a></li><li class="menu"><label>Utility</label><ul class="menu"><li class="menu"><a href="../../../src/FEECa/Utility/Combinatorics.html">Combinatorics.lhs</a></li></ul></li></ul></li>
            </ul>
        </li>
        </ul>
       </div>

      <div id="main">
        <div id="content">

            <h1 id="simplex">Simplex</h1>
<p>The module implements simplices in n-dimensional Euclidean space <span class="math inline">\(\mathbb{R}^{n}\)</span>. A <span class="math inline">\(k\)</span>-simplex <span class="math inline">\(\mathcal{T} = [\boldsymbol{v_0},\ldots,\boldsymbol{v_k}]\)</span> in <span class="math inline">\(n\)</span>-dimensional Euclidean space <span class="math inline">\(\mathbb{R}^{n}\)</span> is the convex hull of <span class="math inline">\(k+1\)</span> vertices <span class="math inline">\(\boldsymbol{v_0},\ldots,\boldsymbol{v_k}\)</span> such that the spanning vectors <span class="math inline">\(\boldsymbol{v_1}-\boldsymbol{v_0} ,\ldots,\boldsymbol{v_k}-\boldsymbol{v_0}\)</span> are linearly independent. The <em>topological dimension</em> of a simplex is the number <span class="math inline">\(k\)</span> of vectors spanning the simplex. The <em>geometrical dimension</em> of a simplex is the dimension <span class="math inline">\(n\)</span> of the underlying space <span class="math inline">\(\mathbb{R}^{n}\)</span>. If <span class="math inline">\(k=n\)</span>, we speak of a full simplex. A subsimplex of a given simplex <span class="math inline">\(\mathcal{T} = [\boldsymbol{v_0},\ldots,\boldsymbol{v_k}]\)</span> is a simplex <span class="math inline">\(\mathcal{T'} = [\boldsymbol{v_{i_0}},\ldots,\boldsymbol{v_{i_{k'}}}]\)</span> such that <span class="math inline">\(\{i_0,\ldots,i_{k'}\} \subset \{1,\ldots,k\}\)</span>. Such a subsimplex can be conveniently represented using a map <span class="math inline">\(\sigma: \{0,\ldots,k'\} \to \{0,\ldots,k\}\)</span> such that <span class="math inline">\(\sigma(j) = i_j\)</span> for all <span class="math inline">\(j=0,\ldots,k'\)</span>. For the representation to be unique, we require <span class="math inline">\(\sigma\)</span> to be increasing, i.e. <span class="math inline">\(\sigma(j+1) &gt; \sigma(j)\)</span> for all <span class="math inline">\(j=1,\ldots,k'-1\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">{-# LANGUAGE MultiParamTypeClasses  #-}</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">{-# LANGUAGE FlexibleContexts       #-}</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">{-# LANGUAGE TypeFamilies           #-}</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="ot">{-# LANGUAGE FlexibleInstances      #-}</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">module</span> <span class="dt">FEECa.Internal.Simplex</span> (</a>
<a class="sourceLine" id="cb1-8" title="8">  <span class="co">-- * The Simplex type</span></a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="dt">Simplex</span>(<span class="op">..</span>), simplex, simplex', referenceSimplex, face,</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="co">-- ** Properties</span></a>
<a class="sourceLine" id="cb1-12" title="12">  geometricalDimension, topologicalDimension, volume, spanningVectors,</a>
<a class="sourceLine" id="cb1-13" title="13">  referenceVertex, extendVectors,</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15">  <span class="co">-- * Subsimplices</span></a>
<a class="sourceLine" id="cb1-16" title="16">  subsimplex, subsimplices, subsimplices', extendSimplex, complement,</a>
<a class="sourceLine" id="cb1-17" title="17">  boundary, boundarySigns,</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19">  <span class="co">-- * Integration</span></a>
<a class="sourceLine" id="cb1-20" title="20">  integrateOverSimplex,</a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22">  <span class="co">-- * Coordinates</span></a>
<a class="sourceLine" id="cb1-23" title="23">  cubicToBarycentric, barycentricToCartesian, cubicToCartesian</a>
<a class="sourceLine" id="cb1-24" title="24">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="kw">import</span> <span class="dt">Prelude</span>    <span class="kw">hiding</span>  ( (&lt;&gt;) )</a>
<a class="sourceLine" id="cb1-27" title="27"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="kw">import</span> <span class="kw">qualified</span>  <span class="dt">Numeric.LinearAlgebra.HMatrix</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="kw">import</span> <span class="dt">FEECa.Internal.Spaces</span></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="kw">import</span> <span class="dt">FEECa.Utility.Combinatorics</span></a>
<a class="sourceLine" id="cb1-32" title="32"><span class="kw">import</span> <span class="dt">FEECa.Utility.GramSchmidt</span></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="kw">import</span> <span class="dt">FEECa.Utility.Print</span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="kw">import</span> <span class="dt">FEECa.Utility.Quadrature</span></a>
<a class="sourceLine" id="cb1-35" title="35"><span class="kw">import</span> <span class="kw">qualified</span>  <span class="dt">FEECa.Utility.Utility</span>         <span class="kw">as</span> <span class="dt">U</span></a>
<a class="sourceLine" id="cb1-36" title="36"></a></code></pre></div>
<h2 id="the-type">The type</h2>
<p>We represent a simplex <span class="math inline">\(\mathcal{T} = [\boldsymbol{v_0},\ldots,\boldsymbol{v_k}]\)</span> by a list containing the vertices <span class="math inline">\(\boldsymbol{v_0},\ldots,\boldsymbol{v_k}\)</span> and an increasing map <span class="math inline">\(\sigma\)</span> keeping track of which vertices of a potential super-simplex the simplex contains. The mapping <span class="math inline">\(\sigma\)</span> is represented by an increasing list <span class="math inline">\(\sigma(1),\ldots, \sigma(k)\)</span>.</p>
<p>The type is parametrized by the type used to represent vectors in <span class="math inline">\(\mathbb{R}^{n}\)</span>. The type contains two fields. represents the mapping <span class="math inline">\(\sigma\)</span> and the vertices of the simplex. For full simplices, <span class="math inline">\(\sigma\)</span> is just <span class="math inline">\(0,\ldots,n\)</span>. For subsimplices of another simplex, <span class="math inline">\(\sigma\)</span> keeps track of which of the vertices of the supersimplex are included in the subsimplex. This is needed for the extension of polynomials defined on a subsimplex of another simplex to the simplex itself.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="co">-- | n-simplex represented by a list of vectors of given dimensionality</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">-- | Invariant: geometrical dimension = length of the vertices - 1</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">data</span> <span class="dt">Simplex</span> a <span class="ot">=</span>  <span class="dt">Simplex</span> {<span class="ot"> sigma ::</span> [<span class="dt">Int</span>],</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">                            vertices ::</span> [a] }</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">-- | The geometrical dimension of a simplex is the dimensionality of the</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="co">-- | underlying vector space.</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="ot">geometricalDimension ::</span> <span class="dt">Dimensioned</span> a <span class="ot">=&gt;</span> <span class="dt">Simplex</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-10" title="10">geometricalDimension (<span class="dt">Simplex</span> _ (p<span class="op">:</span>_)) <span class="ot">=</span> dim p</a>
<a class="sourceLine" id="cb2-11" title="11">geometricalDimension _                 <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;geometricalDimension: empty list or vertices&quot;</span></a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co">-- | The topological dimension of a n-simplex is the number of vertices minus</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co">-- | one.</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="ot">topologicalDimension ::</span> <span class="dt">Simplex</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-16" title="16">topologicalDimension (<span class="dt">Simplex</span> _ l) <span class="ot">=</span> <span class="fu">length</span> l <span class="op">-</span> <span class="dv">1</span></a></code></pre></div>
<p>We call the first vertex <span class="math inline">\(\boldsymbol{v_0}\)</span> of a simplex <span class="math inline">\(\mathcal{T} = [\boldsymbol{v_0},\ldots,\boldsymbol{v_k}]\)</span> as its reference vertex. The vectors <span class="math inline">\(\boldsymbol{v_1}-\boldsymbol{v_0},\ldots,\boldsymbol{v_n}-\boldsymbol{v_0}\)</span>. are referred to as the simplices spanning vectors.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="co">-- | Reference vertex of the simplex, i.e. the first point in the list</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co">-- | of vectors</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">referenceVertex ::</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb3-4" title="4">referenceVertex (<span class="dt">Simplex</span> _ (p<span class="op">:</span>_)) <span class="ot">=</span> p</a>
<a class="sourceLine" id="cb3-5" title="5">referenceVertex _                 <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;referenceVertex: there is no vertex in this simplex&quot;</span></a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="co">-- | List of the n direction vector pointing from the first point of the</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="co">-- | simplex to the others.</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="ot">spanningVectors ::</span> <span class="dt">VectorSpace</span> v <span class="ot">=&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> [v]</a>
<a class="sourceLine" id="cb3-10" title="10">spanningVectors (<span class="dt">Simplex</span> _ (v<span class="op">:</span>vs)) <span class="ot">=</span> <span class="fu">map</span> (<span class="ot">`subV`</span> v) vs</a>
<a class="sourceLine" id="cb3-11" title="11">spanningVectors (<span class="dt">Simplex</span> _ _)      <span class="ot">=</span> []</a></code></pre></div>
<h3 id="printing-simplices">Printing Simplices</h3>
<p>For printing of simplices two methods are provided. As an instance of the class¸ displays the internal structure of the type. renders the simplex as a list of vectors using unicode.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">instance</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> <span class="dt">Pretty</span> (<span class="dt">Simplex</span> v) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  pPrint t<span class="op">@</span>(<span class="dt">Simplex</span> _ l) <span class="ot">=</span> int m <span class="op">&lt;&gt;</span> text <span class="st">&quot;-Simplex in &quot;</span></a>
<a class="sourceLine" id="cb4-3" title="3">                            <span class="op">&lt;&gt;</span> rn n <span class="op">$+$</span> <span class="co">-- &lt;&gt; text &quot;:\n&quot;</span></a>
<a class="sourceLine" id="cb4-4" title="4">                            printVectorRow <span class="dv">2</span> cs</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">where</span> cs <span class="ot">=</span> <span class="fu">map</span> toDouble' l</a>
<a class="sourceLine" id="cb4-6" title="6">          n  <span class="ot">=</span> geometricalDimension t</a>
<a class="sourceLine" id="cb4-7" title="7">          m  <span class="ot">=</span> topologicalDimension t</a></code></pre></div>
<h3 id="constructors">Constructors</h3>
<p>The type provides two different constructors for the construction of full simplices. The constructor creates a simplex from a given list of vertices. The constructor creates a simplex from a given reference vertex <span class="math inline">\(\boldsymbol{v_0}\)</span> and <span class="math inline">\(n\)</span> direction vectors <span class="math inline">\(\boldsymbol{v_1}-\boldsymbol{v_0},\ldots,\boldsymbol{v_n}-\boldsymbol{v_0}\)</span>. In both cases the topological dimension of the simplex must agree with the geometrical one, otherwise an error is thrown.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">-- | Construct a full simplex from a given list of points in R^n</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ot">simplex ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> [v] <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v</a>
<a class="sourceLine" id="cb5-4" title="4">simplex []        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;simplex: empty list.&quot;</span></a>
<a class="sourceLine" id="cb5-5" title="5">simplex l<span class="op">@</span>(p<span class="op">:</span>_)</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="op">|</span> dim p <span class="op">==</span> n  <span class="ot">=</span> <span class="dt">Simplex</span> [<span class="dv">0</span><span class="op">..</span>n] l</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;simplex: Dimensions don't agree.&quot;</span></a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="kw">where</span> n <span class="ot">=</span> <span class="fu">length</span> l <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">-- | Construct a full simplex from a reference vertex and n direction vectors.</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="ot">simplex' ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> v <span class="ot">-&gt;</span> [v] <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v</a>
<a class="sourceLine" id="cb5-12" title="12">simplex' _  []             <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;simplex': Topological dimension is zero.&quot;</span></a>
<a class="sourceLine" id="cb5-13" title="13">simplex' p0 vs</a>
<a class="sourceLine" id="cb5-14" title="14">    <span class="op">|</span> <span class="fu">all</span> ((n<span class="op">==</span>) <span class="op">.</span> dim) vs <span class="ot">=</span> <span class="dt">Simplex</span> [<span class="dv">0</span><span class="op">..</span>n] (p0<span class="op">:</span>vs')</a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="op">|</span> <span class="fu">otherwise</span>            <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;simplex': Dimensions don't agree.&quot;</span></a>
<a class="sourceLine" id="cb5-16" title="16">  <span class="kw">where</span> vs' <span class="ot">=</span> <span class="fu">map</span> (addV p0) vs</a>
<a class="sourceLine" id="cb5-17" title="17">        n   <span class="ot">=</span> <span class="fu">length</span> vs</a></code></pre></div>
<p>The function constructs the reference simplex in <span class="math inline">\(\mathbb{R}^{n}\)</span>, which is defined as the simplex <span class="math inline">\(T=[\boldsymbol{v_0},\ldots,\boldsymbol{v_n}]\)</span> with vertices <span class="math display">\[\begin{aligned}
  \boldsymbol{v_0} =
\left [ \begin{array}{c} 0 \\ 0 \\ \vdots \\ 0 \end{array} \right ],
  \boldsymbol{v_1} =
\left [ \begin{array}{c} 1 \\ 0 \\ \vdots \\ 0 \end{array} \right ],
  \boldsymbol{v_2} =
\left [ \begin{array}{c} 0 \\ 1 \\ \vdots \\ 0 \end{array} \right ],
\ldots,
  \boldsymbol{v_n} =
\left [ \begin{array}{c} 0 \\ 0 \\ \vdots \\ 1 \end{array} \right ]\end{aligned}\]</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="co">-- | Reference simplex in R^n</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">referenceSimplex ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v</a>
<a class="sourceLine" id="cb6-3" title="3">referenceSimplex n <span class="ot">=</span> <span class="dt">Simplex</span> [<span class="dv">0</span><span class="op">..</span>n] (zero n <span class="op">:</span> [unitVector n i <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>n<span class="op">-</span><span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="ot">face ::</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v</a>
<a class="sourceLine" id="cb6-6" title="6">face (<span class="dt">Simplex</span> sigma1 vs) sigma2 <span class="ot">=</span> <span class="dt">Simplex</span> [sigma1 <span class="op">!!</span> i <span class="op">|</span> i <span class="ot">&lt;-</span> sigma2]</a>
<a class="sourceLine" id="cb6-7" title="7">                                          [vs <span class="op">!!</span> i     <span class="op">|</span> i <span class="ot">&lt;-</span> sigma2]</a></code></pre></div>
<h2 id="volume-of-a-simplex">Volume of a Simplex</h2>
<p>The volume of a full simplex <span class="math inline">\(\mathcal{T}\)</span> in n dimensions is given by <span class="math display">\[\begin{aligned}
\label{eq:simplex_vol}
  V(\mathcal{T}) &amp;=
  \left | \frac{1}{n!}\text{det}\{\boldsymbol{v_1}-\boldsymbol{v_0},
                                  \ldots,
                                  \boldsymbol{v_n}-\boldsymbol{v_0}\} \right |
 \end{aligned}\]</span> If the topological dimension of the simplex is less than k, it is necessary to project the spanning vectors <span class="math inline">\(v_n-v_0,\ldots,v_1-v_0\)</span> onto the space spanned by the subsimplex first. This is done by first constructing an orthonormal basis of the space using the Gram-Schmidt method and then projecting the spanning vectors onto that space.</p>
<p>The function checks whether the given simplex has full space dimension and if not performs the projection using and . simply uses the above formula to compute the volume of a full simplex <span class="math inline">\(\mathcal{T}\)</span>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="co">-- | Computes the k-dimensional volume (Lebesgue measure) of a simplex</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co">-- | in n dimensions using the Gram Determinant rule.</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">volume ::</span> <span class="dt">EuclideanSpace</span> v</a>
<a class="sourceLine" id="cb7-5" title="5">       <span class="ot">=&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> <span class="dt">Scalar</span> v</a>
<a class="sourceLine" id="cb7-6" title="6">volume t</a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="op">|</span> k <span class="op">==</span> n     <span class="ot">=</span> volume' t</a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> volume (simplex' (zero k) (project bs vs))</a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="kw">where</span> k  <span class="ot">=</span> topologicalDimension t</a>
<a class="sourceLine" id="cb7-10" title="10">        n  <span class="ot">=</span> geometricalDimension t</a>
<a class="sourceLine" id="cb7-11" title="11">        vs <span class="ot">=</span> spanningVectors t</a>
<a class="sourceLine" id="cb7-12" title="12">        bs <span class="ot">=</span> gramSchmidt vs</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="ot">project ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> [v] <span class="ot">-&gt;</span> [v] <span class="ot">-&gt;</span> [v]</a>
<a class="sourceLine" id="cb7-15" title="15">project bs vs <span class="ot">=</span> <span class="fu">map</span> fromList [[ proj b v <span class="op">|</span> b <span class="ot">&lt;-</span> bs] <span class="op">|</span> v <span class="ot">&lt;-</span> vs]</a>
<a class="sourceLine" id="cb7-16" title="16">  <span class="kw">where</span> proj b v  <span class="ot">=</span> divide (dot b v) (sqrt' (dot b b))</a>
<a class="sourceLine" id="cb7-17" title="17">        sqrt'     <span class="ot">=</span> <span class="fu">fromDouble</span> <span class="op">.</span> <span class="fu">sqrt</span> <span class="op">.</span> toDouble</a>
<a class="sourceLine" id="cb7-18" title="18"></a>
<a class="sourceLine" id="cb7-19" title="19"><span class="ot">volume' ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> <span class="dt">Scalar</span> v</a>
<a class="sourceLine" id="cb7-20" title="20">volume' t <span class="ot">=</span> <span class="fu">fromDouble</span> <span class="op">$</span>  <span class="fu">abs</span> (M.det w) <span class="op">/</span> <span class="fu">fromInteger</span> (factorial n)</a>
<a class="sourceLine" id="cb7-21" title="21">  <span class="kw">where</span> n <span class="ot">=</span> geometricalDimension t</a>
<a class="sourceLine" id="cb7-22" title="22">        w <span class="ot">=</span> M.matrix n comps</a>
<a class="sourceLine" id="cb7-23" title="23">        comps <span class="ot">=</span> <span class="fu">concatMap</span> toDouble' (spanningVectors t)</a></code></pre></div>
<h2 id="subsimplices">Subsimplices</h2>
<p>A subsimplex, or face, <span class="math inline">\(\mathcal{f}\)</span> of dimension <span class="math inline">\(k\)</span> of a simplex <span class="math inline">\(\mathcal{T} = [\boldsymbol{v_0},\ldots,\boldsymbol{v_n}]\)</span> is any simplex consisting of a subset <span class="math inline">\(\boldsymbol{v_{i_0}},\ldots,\boldsymbol{v_{i_k}}\)</span> of the vertices <span class="math inline">\(v_0,\ldots,v_n\)</span>. Such a <span class="math inline">\(k\)</span>-subsimplex of a given simplex may be identified by an increasing map <span class="math inline">\(\sigma\)</span>. Using lexicographic ordering of the increasing maps of a given length it is possible to define an ordering over the simplices. This allows us to index each subsimplex of a given dimension <span class="math inline">\(k\)</span> of a simplex.</p>
<p>Three functions are provided to obtain subsimplices from a given simplex. returns the <span class="math inline">\(i\)</span>th <span class="math inline">\(k\)</span>-subsimplex of a given simplex. returns a list of all the subsimplices of dimension <span class="math inline">\(k\)</span> and returns a list of all the subsimplices of dimension <span class="math inline">\(k\)</span> or higher.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="co">-- | i:th k-dimensional subsimplex of given simplex</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">subsimplex ::</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v</a>
<a class="sourceLine" id="cb8-3" title="3">subsimplex (<span class="dt">Simplex</span> _ []) _ _ <span class="ot">=</span></a>
<a class="sourceLine" id="cb8-4" title="4">      <span class="fu">error</span> <span class="st">&quot;subsimplex: Encountered Simplex without vertices.&quot;</span></a>
<a class="sourceLine" id="cb8-5" title="5">subsimplex s<span class="op">@</span>(<span class="dt">Simplex</span> _ l) k i</a>
<a class="sourceLine" id="cb8-6" title="6">    <span class="op">|</span> k <span class="op">&gt;</span> n                     <span class="ot">=</span> <span class="fu">error</span> err_dim</a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="op">|</span> i <span class="op">&gt;=</span> (n<span class="op">+</span><span class="dv">1</span>) <span class="ot">`choose`</span> (k<span class="op">+</span><span class="dv">1</span>) <span class="ot">=</span> <span class="fu">error</span> err_ind</a>
<a class="sourceLine" id="cb8-8" title="8">    <span class="op">|</span> <span class="fu">otherwise</span>                 <span class="ot">=</span> <span class="dt">Simplex</span> indices (U.takeIndices l indices)</a>
<a class="sourceLine" id="cb8-9" title="9">  <span class="kw">where</span> n <span class="ot">=</span> topologicalDimension s</a>
<a class="sourceLine" id="cb8-10" title="10">        indices <span class="ot">=</span> unrank (k<span class="op">+</span><span class="dv">1</span>) n i</a>
<a class="sourceLine" id="cb8-11" title="11">        err_ind <span class="ot">=</span> <span class="st">&quot;subsimplex: Index of subsimplex exceeds (n+1) choose (k+1).&quot;</span></a>
<a class="sourceLine" id="cb8-12" title="12">        err_dim <span class="ot">=</span> <span class="st">&quot;subsimplex: Dimensionality of subsimplex is higher than&quot;</span></a>
<a class="sourceLine" id="cb8-13" title="13">                  <span class="op">++</span> <span class="st">&quot; that of the simplex.&quot;</span></a>
<a class="sourceLine" id="cb8-14" title="14"></a>
<a class="sourceLine" id="cb8-15" title="15"><span class="co">-- | List subsimplices of given simplex with dimension k.</span></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="ot">subsimplices ::</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Simplex</span> v]</a>
<a class="sourceLine" id="cb8-17" title="17">subsimplices t<span class="op">@</span>(<span class="dt">Simplex</span> _ l) k</a>
<a class="sourceLine" id="cb8-18" title="18">    <span class="op">|</span> k <span class="op">&gt;</span> n     <span class="ot">=</span> <span class="fu">error</span> err_dim</a>
<a class="sourceLine" id="cb8-19" title="19">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> [ <span class="dt">Simplex</span> ix (U.takeIndices l ix) <span class="op">|</span></a>
<a class="sourceLine" id="cb8-20" title="20">                      ix <span class="ot">&lt;-</span> increasingLists (k<span class="op">+</span><span class="dv">1</span>) n ]</a>
<a class="sourceLine" id="cb8-21" title="21">  <span class="kw">where</span> n       <span class="ot">=</span> topologicalDimension t</a>
<a class="sourceLine" id="cb8-22" title="22">        err_dim <span class="ot">=</span> <span class="st">&quot;subsimplices: Dimensionality of subsimplices is&quot;</span></a>
<a class="sourceLine" id="cb8-23" title="23">                  <span class="op">++</span> <span class="st">&quot;higher than that of the simplex.&quot;</span></a>
<a class="sourceLine" id="cb8-24" title="24"><span class="co">-- TODO: note that the implementation has always seemed to ignore the original</span></a>
<a class="sourceLine" id="cb8-25" title="25"><span class="co">--  &quot;permutation&quot; of indices we had from the original simplex if the argument</span></a>
<a class="sourceLine" id="cb8-26" title="26"><span class="co">--  happens to be a subsimplex, ie: non-full simmplex. Now, should we check or</span></a>
<a class="sourceLine" id="cb8-27" title="27"><span class="co">--  is it intended functionality?</span></a>
<a class="sourceLine" id="cb8-28" title="28"></a>
<a class="sourceLine" id="cb8-29" title="29"><span class="co">-- | List subsimplices of given simplex with dimension larger or equal to k.</span></a>
<a class="sourceLine" id="cb8-30" title="30"><span class="ot">subsimplices' ::</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Simplex</span> v]</a>
<a class="sourceLine" id="cb8-31" title="31">subsimplices' t k <span class="ot">=</span> <span class="fu">concat</span> [ subsimplices t k' <span class="op">|</span> k' <span class="ot">&lt;-</span> [k<span class="op">..</span>n] ]</a>
<a class="sourceLine" id="cb8-32" title="32">  <span class="kw">where</span> n <span class="ot">=</span> topologicalDimension t</a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">complement ::</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> [v]</a>
<a class="sourceLine" id="cb9-2" title="2">complement (<span class="dt">Simplex</span> _ l) (<span class="dt">Simplex</span> sigm _) <span class="ot">=</span> [l <span class="op">!!</span> i <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>n], i <span class="ot">`notElem`</span> sigm]</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">where</span> n <span class="ot">=</span> <span class="fu">length</span> l <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="ot">boundary ::</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> [<span class="dt">Simplex</span> v]</a>
<a class="sourceLine" id="cb9-6" title="6">boundary t</a>
<a class="sourceLine" id="cb9-7" title="7">  <span class="op">|</span> k <span class="op">&lt;=</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="fu">error</span> err_dim</a>
<a class="sourceLine" id="cb9-8" title="8">  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> subsimplices t (k<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-9" title="9">  <span class="kw">where</span> k <span class="ot">=</span> topologicalDimension t</a>
<a class="sourceLine" id="cb9-10" title="10">        err_dim <span class="ot">=</span> <span class="st">&quot;boundary: Can't take the boundary of a simplex with topological dimension &quot;</span></a>
<a class="sourceLine" id="cb9-11" title="11">                  <span class="op">++</span> <span class="st">&quot;less than 1.&quot;</span></a>
<a class="sourceLine" id="cb9-12" title="12"></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="ot">boundarySigns ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> [<span class="dt">Scalar</span> v]</a>
<a class="sourceLine" id="cb9-14" title="14">boundarySigns t</a>
<a class="sourceLine" id="cb9-15" title="15">  <span class="op">|</span> k <span class="op">&lt;=</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="fu">error</span> err_dim</a>
<a class="sourceLine" id="cb9-16" title="16">  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">map</span> (\x <span class="ot">-&gt;</span> <span class="kw">if</span> (<span class="fu">even</span> x) <span class="kw">then</span> mulId <span class="kw">else</span> addInv mulId) [<span class="dv">0</span><span class="op">..</span>k]</a>
<a class="sourceLine" id="cb9-17" title="17">  <span class="kw">where</span> k <span class="ot">=</span> topologicalDimension t</a>
<a class="sourceLine" id="cb9-18" title="18">        err_dim <span class="ot">=</span> <span class="st">&quot;boundary: Can't take the boundary of a simplex with topological dimension &quot;</span></a>
<a class="sourceLine" id="cb9-19" title="19">                  <span class="op">++</span> <span class="st">&quot;less than 1.&quot;</span></a></code></pre></div>
<p>For the computation of the barycentric coordinates of a simplex whose topological dimension is smaller than its geometrical dimension it is necessary to extend the simplex to a full simplex. For a given <span class="math inline">\(k\)</span>-subsimplex in <span class="math inline">\(n\)</span> dimensions this is done by adding <span class="math inline">\(n-k\)</span> vertices <span class="math inline">\(v_{k+1},\ldots,v_{n}\)</span> such that the vectors <span class="math inline">\(v_{k+1}-v_0,\ldots,v_{n}-v_0\)</span> are orthogonal mutually as well as to the vectors <span class="math inline">\(v_{1}-v_{0},\ldots,v_{k}-v_{0}\)</span>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="co">-- | Extend the given simplex to a full simplex so that its geometrical</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">-- | dimension is the same as its topological dimension.</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">extendSimplex ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v</a>
<a class="sourceLine" id="cb10-4" title="4">extendSimplex t</a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="op">|</span> n <span class="op">==</span> nt   <span class="ot">=</span> t</a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> simplex' p0 (extendVectors n dirs)</a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="kw">where</span> n     <span class="ot">=</span> geometricalDimension t</a>
<a class="sourceLine" id="cb10-8" title="8">        nt    <span class="ot">=</span> topologicalDimension t</a>
<a class="sourceLine" id="cb10-9" title="9">        dirs  <span class="ot">=</span> spanningVectors t</a>
<a class="sourceLine" id="cb10-10" title="10">        p0    <span class="ot">=</span> referenceVertex t</a>
<a class="sourceLine" id="cb10-11" title="11"></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="co">-- | Uses the Gram-Schmidt method to add at most n orthogonal vectors to the</span></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="co">-- | given set of vectors. Due to round off error the resulting list may contain</span></a>
<a class="sourceLine" id="cb10-14" title="14"><span class="co">-- | more than n vectors, which then have to be removed manually.</span></a>
<a class="sourceLine" id="cb10-15" title="15"><span class="ot">extendVectors ::</span> <span class="dt">EuclideanSpace</span> v</a>
<a class="sourceLine" id="cb10-16" title="16">              <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [v] <span class="ot">-&gt;</span> [v]</a>
<a class="sourceLine" id="cb10-17" title="17">extendVectors n [] <span class="ot">=</span> extendOrthGS (<span class="dt">Right</span> n)</a>
<a class="sourceLine" id="cb10-18" title="18">extendVectors _ vs <span class="ot">=</span> extendOrthGS (<span class="dt">Left</span> vs)</a>
<a class="sourceLine" id="cb10-19" title="19">    <span class="co">{- XXX: this was there before, jointly with providing GS with the</span></a>
<a class="sourceLine" id="cb10-20" title="20"><span class="co">            n unit vectors in addition to vs, but it seems to be quite</span></a>
<a class="sourceLine" id="cb10-21" title="21"><span class="co">            unnecessary; the comment in the function description doesn't seem</span></a>
<a class="sourceLine" id="cb10-22" title="22"><span class="co">            to apply since we know at most n-k additional vectors could ever</span></a>
<a class="sourceLine" id="cb10-23" title="23"><span class="co">            form an orthogonal basis jointly with vs; changed it so that GS</span></a>
<a class="sourceLine" id="cb10-24" title="24"><span class="co">            takes care of this, as would be expected (ie: it will give at most</span></a>
<a class="sourceLine" id="cb10-25" title="25"><span class="co">            n orthogonal vectors where n = dim (EuclideanSpace v):</span></a>
<a class="sourceLine" id="cb10-26" title="26"><span class="co">        take (n - k)  (U.sortOn (Down . norm2) us</span></a>
<a class="sourceLine" id="cb10-27" title="27"><span class="co">      where us = {-drop k $ -}gramSchmidt $ vs ++ [unitVector n i | i &lt;- [0..(n-1)]]</span></a>
<a class="sourceLine" id="cb10-28" title="28"><span class="co">            k  = length vs -}</span></a></code></pre></div>
<h2 id="sec:Coordinates">Coordinates</h2>
<p>In exterior calculus we will be working with two different coordinates systems: Standard cartesian coordinates and barycentric coordinates of a given simplex. Moreover, for the computation of integrals over a simplex we will use an additional set of coordinates to which we will refer to as cubic coordinates.</p>
<h3 id="barycentric-coordinates">Barycentric Coordinates</h3>
<p>In barycentric coordinates, a point inside a simplex <span class="math inline">\(\mathcal{T} = [\boldsymbol{v_0},\ldots,\boldsymbol{v_n}]\)</span> is given by a convex combination of its vertices. That is, a point <span class="math inline">\(\boldsymbol{p}\)</span> is given in barycentric coordinates by a tuple <span class="math inline">\((\lambda_0,\ldots,\lambda_n)\)</span> if</p>
<p><span class="math display">\[\begin{aligned}
   \boldsymbol{p} &amp;= \lambda_0\boldsymbol{v_0} + \ldots + \lambda_n\boldsymbol{v_n}
 \end{aligned}\]</span></p>
<p>The barycentric coordinates of a point inside a simplex are either positive or zero and sum to one. Moreover, the barycentric coordinates of the vertices of the simplex are given by</p>
<p><span class="math display">\[\begin{aligned}
   \boldsymbol{v_0} = (1,0,\ldots,0), \boldsymbol{v_1} = (0,1,\ldots,0),\ldots,
   \boldsymbol{v_n}=(0,0,\ldots,1)
 \end{aligned}\]</span></p>
<p>The function <code>barycentricToCartesian</code> converts a vector given in barycentric coordinates to cartesian coordinates:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">-- | Convert a vector given in barycentric coordinates to euclidean coordinates.</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="ot">barycentricToCartesian ::</span> <span class="dt">EuclideanSpace</span> v</a>
<a class="sourceLine" id="cb11-4" title="4">                       <span class="ot">=&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb11-5" title="5">barycentricToCartesian (<span class="dt">Simplex</span> _ vs) v <span class="ot">=</span> U.sumV (<span class="fu">zipWith</span> sclV (toList v) vs)</a></code></pre></div>
<h3 id="cubic-coordinates">Cubic Coordinates</h3>
<p>A mapping between points in the n-dimensional unit cube <span class="math inline">\(t = (t_0,\ldots,t_{n-1}) \in [0,1]^{n}\)</span> and the barycentric coordinates of a simplex <span class="math inline">\(\mathcal{T}\)</span> can be defined using</p>
<p><span class="math display">\[\begin{aligned}
    \lambda_0 &amp;= t_0 \\
    \lambda_1 &amp;= t_1(1 - \lambda_0) \\
    \lambda_2 &amp;= t_2(1 - \lambda_1 - \lambda_0) \\
    &amp; \vdots \\
    \lambda_{n-1} &amp;= t_{n-1}(1 - \lambda_{n-1} - \cdots - \lambda_0) \\
    \lambda_{n} &amp;= 1 - \lambda_{n-1} - \cdots - \lambda_0
  \end{aligned}\]</span></p>
<p>We refer to the tuple <span class="math inline">\((t_0,\ldots,t_{n-1})\)</span> as the cubic coordinates of the corresponding point <span class="math inline">\((\lambda_0,\ldots,\lambda_n)\)</span> in barycentric coordinates.</p>
<p>The functions <code>cubicToCartesian</code> and <code>cubicToBarycentric</code> convert from the cubic coordinate system to Cartesian and barycentric coordinates, respectively. Note that cubic coordinates define a point in space only with respect to a given simplex.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="co">-- | The inverse Duffy transform. Maps a point from the unit cube in R^{n+1}</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">-- | to Euclidean space.</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="ot">cubicToCartesian ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb12-4" title="4">cubicToCartesian t <span class="ot">=</span> barycentricToCartesian t <span class="op">.</span> cubicToBarycentric</a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">-- | Convert vector given in cubic coordinates to barycentric coordinates.</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="ot">cubicToBarycentric ::</span> <span class="dt">EuclideanSpace</span> v <span class="ot">=&gt;</span> v <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb12-8" title="8">cubicToBarycentric v <span class="ot">=</span> fromList (ls <span class="op">++</span> [l])</a>
<a class="sourceLine" id="cb12-9" title="9">  <span class="kw">where</span> ts      <span class="ot">=</span> toList v</a>
<a class="sourceLine" id="cb12-10" title="10">        (l,ls)  <span class="ot">=</span> mapAccumL f mulId ts</a>
<a class="sourceLine" id="cb12-11" title="11">        f acc t <span class="ot">=</span> (mul acc (sub mulId t), mul t acc)</a></code></pre></div>
<h2 id="integrals-over-simplices">Integrals over Simplices</h2>
<p>For the integration of a function <span class="math inline">\(f\)</span> over a simplex <span class="math inline">\(\mathcal{T}\)</span> we use the method proposed in <span class="citation" data-cites="Ainsworth">(Ainsworth, Andriamaro, and Davydov 2011)</span>. Performing a change of coordinates from Cartesian to cubic coordinates, the integral over the simplex takes the form</p>
<p><span class="math display">\[\begin{aligned}
   \int_\mathcal{T} d\boldsymbol{x} \: f(\boldsymbol{x}) \:  &amp;=
   V(\mathcal{T}) \int_0^1 dt_1(1-t_1)^{n-1}\ldots\int_0^1 dt_nf(\boldsymbol{x}(t_0,\ldots,t_{n-1}))
 \end{aligned}\]</span></p>
<p>where <span class="math inline">\(V(\mathcal{T})\)</span> is the volume of the simplex. For a numerical approximation of the integral, the factors <span class="math inline">\((1-t_i)^{n-i}\)</span> can be absorbed into the quadrature rule by using a Gauss-Jacobi quadrature</p>
<p><span class="math display">\[\begin{aligned}
  \int_0^1 dt_i(1-t_i)^\alpha = \sum_{j=0}^q w^\alpha_j f(\xi^\alpha_j)\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\alpha=n-i\)</span>. The points <span class="math inline">\(\xi^\alpha_j\)</span> are the roots of the Jacobi polynomial <span class="math inline">\(P_q^{\alpha,0}\)</span> and the <span class="math inline">\(w^\alpha_j\)</span> the corresponding weights, that can be computed using the Golub-Welsch algorithm <span class="citation" data-cites="GolubWelsch">(Golub and Welsch 1969)</span>. The integral of <span class="math inline">\(f\)</span> over <span class="math inline">\(\mathcal{T}\)</span> can then be approximated using</p>
<p><span class="math display">\[\begin{aligned}
\label{eq:integral}
  \int_\mathcal{T} d\boldsymbol{x} \: f(\boldsymbol{x}) \:&amp;=
  V(\mathcal{T}) \sum_{j_1=0}^q w^{n-1}_{j_1}\ldots \sum_{j_n=0}^qw_{j_n}f(\xi^0_{j_n}) \end{aligned}\]</span></p>
<p>The above formula is implemented by the function <code>integral</code>. The computation of the quadrature weights and nodes is implemented in <code>FEECa.Utility.Quadrature</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co">-- | Numerically integrate the function f over the simplex t using a Gauss-Jacobi</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">-- | quadrature rule with q nodes.</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="ot">integrateOverSimplex ::</span> (<span class="dt">EuclideanSpace</span> v, r <span class="op">~</span> <span class="dt">Scalar</span> v)</a>
<a class="sourceLine" id="cb13-5" title="5">                     <span class="ot">=&gt;</span> <span class="dt">Int</span>             <span class="co">-- q</span></a>
<a class="sourceLine" id="cb13-6" title="6">                     <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v       <span class="co">-- t</span></a>
<a class="sourceLine" id="cb13-7" title="7">                     <span class="ot">-&gt;</span> (v <span class="ot">-&gt;</span> r)        <span class="co">-- f</span></a>
<a class="sourceLine" id="cb13-8" title="8">                     <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb13-9" title="9">integrateOverSimplex q t f <span class="ot">=</span> mul vol (<span class="co">{-mul fac-}</span> nestedSum q t f (n<span class="op">-</span><span class="dv">1</span>) [])</a>
<a class="sourceLine" id="cb13-10" title="10">  <span class="kw">where</span> n   <span class="ot">=</span> topologicalDimension t</a>
<a class="sourceLine" id="cb13-11" title="11">        <span class="co">--fac = embedIntegral 1 -- (fromDouble . fromInteger) (factorial n)</span></a>
<a class="sourceLine" id="cb13-12" title="12">        vol <span class="ot">=</span> volume t</a>
<a class="sourceLine" id="cb13-13" title="13"></a>
<a class="sourceLine" id="cb13-14" title="14"><span class="co">-- Recursion for the computation of the nested sum in the numerical approximation</span></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="co">-- of the integral of a function over a simplex.</span></a>
<a class="sourceLine" id="cb13-16" title="16"><span class="ot">nestedSum ::</span> (<span class="dt">EuclideanSpace</span> v, r <span class="op">~</span> <span class="dt">Scalar</span> v)</a>
<a class="sourceLine" id="cb13-17" title="17">             <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Simplex</span> v <span class="ot">-&gt;</span> (v <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb13-18" title="18">nestedSum k t f d ls</a>
<a class="sourceLine" id="cb13-19" title="19">    <span class="op">|</span> d <span class="op">==</span> <span class="dv">0</span>    <span class="ot">=</span> U.sumR [ mul w fx</a>
<a class="sourceLine" id="cb13-20" title="20">                            <span class="op">|</span> (xi,a) <span class="ot">&lt;-</span> quad,</a>
<a class="sourceLine" id="cb13-21" title="21">                              <span class="kw">let</span> w   <span class="ot">=</span> <span class="fu">fromDouble</span> a,</a>
<a class="sourceLine" id="cb13-22" title="22">                              <span class="kw">let</span> fx  <span class="ot">=</span> xNode (f<span class="op">.</span>nodeCoord) xi ]</a>
<a class="sourceLine" id="cb13-23" title="23">                        <span class="co">-- [ mul w (f x)</span></a>
<a class="sourceLine" id="cb13-24" title="24">                        <span class="co">--    | (w, x) &lt;- zip weights' xs ]</span></a>
<a class="sourceLine" id="cb13-25" title="25">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> U.sumR <span class="op">$</span> <span class="fu">map</span> (<span class="fu">uncurry</span> mul <span class="op">.</span> U.pairM (xNode (nestedSum k t f (d<span class="op">-</span><span class="dv">1</span>))) <span class="fu">fromDouble</span>) quad</a>
<a class="sourceLine" id="cb13-26" title="26">                        <span class="co">-- [ mul w (nestedSum k (d-1) (x:ls) t f)</span></a>
<a class="sourceLine" id="cb13-27" title="27">                        <span class="co">--    | (w, x) &lt;- zip weights' nodes' ]</span></a>
<a class="sourceLine" id="cb13-28" title="28">  <span class="kw">where</span> nodeCoord <span class="ot">=</span> cubicToCartesian t <span class="op">.</span> fromList'</a>
<a class="sourceLine" id="cb13-29" title="29">        <span class="co">-- xs        = [ (cubicToCartesian t (fromList' (xi : ls)) , w) | (xi, w) &lt;- quad ]</span></a>
<a class="sourceLine" id="cb13-30" title="30">        fromList' <span class="ot">=</span> fromList <span class="op">.</span> <span class="fu">reverse</span></a>
<a class="sourceLine" id="cb13-31" title="31">        <span class="co">-- TODO: remove list reversal above via a local declaration + accum param</span></a>
<a class="sourceLine" id="cb13-32" title="32">        <span class="co">--      + generalise according to the commong ground found above (via xNode)</span></a>
<a class="sourceLine" id="cb13-33" title="33">        <span class="co">-- wMul      = mul . fromDouble</span></a>
<a class="sourceLine" id="cb13-34" title="34">        xNode h   <span class="ot">=</span> h <span class="op">.</span> (<span class="op">:</span>ls) <span class="op">.</span> <span class="fu">fromDouble</span></a>
<a class="sourceLine" id="cb13-35" title="35">        quad      <span class="ot">=</span> gaussJacobiQuadrature' d <span class="dv">0</span> k</a>
<a class="sourceLine" id="cb13-36" title="36">        <span class="co">-- (nodes, weights) = unzip $ gaussJacobiQuadrature' d 0 k</span></a>
<a class="sourceLine" id="cb13-37" title="37">        <span class="co">-- nodes     = map (fromDouble.fst) quad</span></a>
<a class="sourceLine" id="cb13-38" title="38">        <span class="co">-- weights   = map (fromDouble.snd) quad</span></a>
<a class="sourceLine" id="cb13-39" title="39"></a>
<a class="sourceLine" id="cb13-40" title="40"><span class="kw">instance</span> (<span class="dt">EuclideanSpace</span> v, r <span class="op">~</span> <span class="dt">Scalar</span> v) <span class="ot">=&gt;</span> <span class="dt">FiniteElement</span> (<span class="dt">Simplex</span> v) r <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-41" title="41">  <span class="kw">type</span> <span class="dt">Primitive</span> (<span class="dt">Simplex</span> v) <span class="ot">=</span> v</a>
<a class="sourceLine" id="cb13-42" title="42">  quadrature <span class="ot">=</span> integrateOverSimplex</a></code></pre></div>
<h1 id="bibliography" class="unnumbered">Bibliography</h1>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-Ainsworth">
<p>Ainsworth, Mark, Gaelle Andriamaro, and Oleg Davydov. 2011. “Bernstein–Bézier Finite Elements of Arbitrary Order and Optimal Assembly Procedures.” <em>SIAM Journal on Scientific Computing</em> 33 (6): 3087–3109. <a href="https://doi.org/10.1137/11082539X">https://doi.org/10.1137/11082539X</a>.</p>
</div>
<div id="ref-GolubWelsch">
<p>Golub, Gene H., and John H. Welsch. 1969. “Calculation of Gauss Quadrature Rules.” <em>Mathematics of Computation</em> 23 (106): pp. 221–230+s1–s10. <a href="http://www.jstor.org/stable/2004418">http://www.jstor.org/stable/2004418</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
      </div>
      </div>

    </body>
</html>
