<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>FEECa - PolynomialDifferentialForm</title>
        <link rel="stylesheet" type="text/css" href="../../web/css/default.css" />
    </head>
    <body>

      <div style="width: 1200px; align: center" , id="container">
      <div id="menu">
        <h2 class="nav"> FEECa </h2>
        <ul class="main" style="list-style: none;">
        <li><a href="../../">Home</a></li>
        <li><a href="../../">Examples</a></li>
        <li> Documentation
            <ul class="menu">
            <li class="menu"><label>FEECa</label><ul class="menu"><li class="menu"><a href="../../src/FEECa/Bernstein.html">Bernstein.lhs</a></li><li class="menu"><a href="../../src/FEECa/FiniteElementSpace.html">FiniteElementSpace.lhs</a></li><li class="menu"><label>Internal</label><ul class="menu"><li class="menu"><a href="../../src/FEECa/Internal/MultiIndex.html">MultiIndex.lhs</a></li><li class="menu"><a href="../../src/FEECa/Internal/Point.html">Point.lhs</a></li><li class="menu"><a href="../../src/FEECa/Internal/Simplex.html">Simplex.lhs</a></li><li class="menu"><a href="../../src/FEECa/Internal/Vector.html">Vector.lhs</a></li></ul></li><li class="menu"><a href="../../src/FEECa/Polynomial.html">Polynomial.lhs</a></li><li class="menu"><a href="../../src/FEECa/PolynomialDifferentialForm.html">PolynomialDifferentialForm.lhs</a></li><li class="menu"><label>Utility</label><ul class="menu"><li class="menu"><a href="../../src/FEECa/Utility/Combinatorics.html">Combinatorics.lhs</a></li></ul></li></ul></li>
            </ul>
        </li>
        </ul>
       </div>

      <div id="main">
        <div id="content">

            <div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">
<span class="ot">{-# LANGUAGE GADTs                #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances    #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts     #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class="kw">module</span> <span class="dt">FEECa.PolynomialDifferentialForm</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>  ( liftA2 )
<span class="kw">import </span><span class="dt">Control.Monad</span>        ( <span class="dt">MonadPlus</span> (..) )
<span class="kw">import </span><span class="dt">Data.Foldable</span>  ( <span class="dt">Foldable</span> (..) )
<span class="kw">import </span><span class="dt">Data.Monoid</span>    ( <span class="dt">First</span> (..) )
<span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="kw">import            </span><span class="dt">FEECa.Internal.Vector</span>
<span class="kw">import            </span><span class="dt">FEECa.Internal.Simplex</span>
<span class="kw">import qualified</span>  <span class="dt">FEECa.Bernstein</span>             <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import qualified</span>  <span class="dt">FEECa.Internal.Form</span>         <span class="kw">as</span> <span class="dt">F</span>
<span class="kw">import qualified</span>  <span class="dt">FEECa.DifferentialForm</span>      <span class="kw">as</span> <span class="dt">D</span>
<span class="kw">import qualified</span>  <span class="dt">FEECa.Polynomial</span>            <span class="kw">as</span> <span class="dt">P</span>
<span class="kw">import qualified</span>  <span class="dt">FEECa.Internal.Spaces</span>       <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import qualified</span>  <span class="dt">FEECa.Utility.Combinatorics</span> <span class="kw">as</span> <span class="dt">C</span>
<span class="kw">import qualified</span>  <span class="dt">FEECa.Internal.Vector</span>       <span class="kw">as</span> <span class="dt">V</span>


<span class="kw">type</span> <span class="dt">BernsteinPolynomial</span> a <span class="fu">=</span> <span class="dt">B.BernsteinPolynomial</span> (<span class="dt">Vector</span> a) a
<span class="kw">type</span> <span class="dt">DifferentialForm</span> a    <span class="fu">=</span> <span class="dt">D.DifferentialForm</span> (<span class="dt">BernsteinPolynomial</span> a)

<span class="co">{-</span>
<span class="co">instance  Show (DifferentialForm Double) where</span>
<span class="co">  show omega = show $ printForm (&quot;d&quot; ++ lambda) &quot;0&quot; pPrint (F.terms omega)</span>
<span class="co">-}</span>

<span class="ot">findSimplex ::</span> <span class="dt">DifferentialForm</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Simplex</span> (<span class="dt">Vector</span> a))
findSimplex (<span class="dt">F.Form</span> _ _ cs) <span class="fu">=</span> getFirst <span class="fu">$</span> foldMap (findSimplex' <span class="fu">.</span> fst) cs

<span class="ot">findSimplex' ::</span> <span class="dt">BernsteinPolynomial</span> a <span class="ot">-&gt;</span> <span class="dt">First</span> (<span class="dt">Simplex</span> (<span class="dt">Vector</span> a))
findSimplex' (<span class="dt">B.Bernstein</span> t _)  <span class="fu">=</span> <span class="dt">First</span> (<span class="dt">Just</span> t)
findSimplex' _                  <span class="fu">=</span> <span class="dt">First</span> <span class="dt">Nothing</span>

<span class="ot">tabulate ::</span> (<span class="dt">S.VectorSpace</span> a, <span class="dt">S.Scalar</span> a <span class="fu">~</span> a)
         <span class="ot">=&gt;</span> [<span class="dt">DifferentialForm</span> a]
         <span class="ot">-&gt;</span> [<span class="dt">Vector</span> a]
         <span class="ot">-&gt;</span> [<span class="dt">Simplex</span> (<span class="dt">Vector</span> a)]
         <span class="ot">-&gt;</span> [[a]]
tabulate bs vs fs <span class="fu">=</span> [ evalSeparately t b vs fs' <span class="fu">|</span> b <span class="ot">&lt;-</span> bs ]
  <span class="kw">where</span> t   <span class="fu">=</span> fromJust <span class="fu">$</span> findSimplex <span class="fu">$</span> head bs
        fs' <span class="fu">=</span> map spanningVectors fs

<span class="ot">apply ::</span> <span class="dt">S.Field</span> a
      <span class="ot">=&gt;</span> <span class="dt">DifferentialForm</span> a <span class="ot">-&gt;</span> [<span class="dt">Vector</span> a] <span class="ot">-&gt;</span> <span class="dt">BernsteinPolynomial</span> a
apply omega vs <span class="fu">=</span> <span class="ot">{-# SCC &quot;apply&quot; #-}</span> F.apply ds vs omega
  <span class="kw">where</span> t  <span class="fu">=</span> fromJust (findSimplex omega)
        ds <span class="fu">=</span> P.barycentricGradients t

<span class="ot">evalSeparately ::</span> (<span class="dt">S.VectorSpace</span> a, <span class="dt">S.Scalar</span> a <span class="fu">~</span> a)
               <span class="ot">=&gt;</span> <span class="dt">Simplex</span> (<span class="dt">Vector</span> a)
               <span class="ot">-&gt;</span> <span class="dt">DifferentialForm</span> a
               <span class="ot">-&gt;</span> [<span class="dt">Vector</span> a]
               <span class="ot">-&gt;</span> [[<span class="dt">Vector</span> a]]
               <span class="ot">-&gt;</span> [a]
evalSeparately t omega vs fs <span class="fu">=</span> V.toList <span class="fu">$</span> Prelude.foldl S.addV (S.zero l) crossres
  <span class="kw">where</span> bvals       <span class="fu">=</span> B.tabulateBernstein t vs (fst omegasplit)
        fvals       <span class="fu">=</span> [[F.apply ds f eta <span class="fu">|</span> f <span class="ot">&lt;-</span> fs] <span class="fu">|</span> eta <span class="ot">&lt;-</span> snd omegasplit]
        crossres    <span class="fu">=</span> zipWith (\f v <span class="ot">-&gt;</span> V.vector (liftA2 S.mul f v)) fvals bvals
        ds          <span class="fu">=</span> P.barycentricGradients t
        omegasplit  <span class="fu">=</span> F.split omega
        l           <span class="fu">=</span> length vs <span class="fu">*</span> length fs
        <span class="co">-- zero        = V.vector (replicate l $ S.embedIntegral 0.0)</span>

<span class="ot">inner ::</span> (<span class="dt">S.Field</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">DifferentialForm</span> a <span class="ot">-&gt;</span> <span class="dt">DifferentialForm</span> a <span class="ot">-&gt;</span> a
inner omega eta
    <span class="fu">|</span> isJust t  <span class="fu">=</span> F.inner (B.proj (fromJust t)) omega eta
    <span class="fu">|</span> otherwise <span class="fu">=</span>
        error <span class="st">&quot;Inner: Need associated simplex to compute inner product.&quot;</span>
  <span class="kw">where</span> t <span class="fu">=</span> findSimplex omega <span class="ot">`mplus`</span> findSimplex eta

<span class="ot">integrate ::</span> <span class="dt">S.Field</span> a <span class="ot">=&gt;</span> <span class="dt">Simplex</span> (<span class="dt">Vector</span> a) <span class="ot">-&gt;</span> <span class="dt">DifferentialForm</span> a <span class="ot">-&gt;</span> a
integrate t omega <span class="fu">=</span> S.divide (B.integratePolynomial t b) (S.mul kfac (volume t))
  <span class="kw">where</span> b    <span class="fu">=</span> apply omega (spanningVectors t)
        <span class="co">-- b'   = S.sclV (S.mulInv (S.mul kfac (volume t))) b</span>
        kfac <span class="fu">=</span> S.embedIntegral (C.factorial (topologicalDimension t))</code></pre></div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
      </div>
      </div>

    </body>
</html>
